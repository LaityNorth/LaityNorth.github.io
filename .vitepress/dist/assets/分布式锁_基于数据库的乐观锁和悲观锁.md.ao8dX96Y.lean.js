import{_ as l,D as p,c as h,j as i,a as s,I as n,a1 as k,o as t}from"./chunks/framework.DFHaK-wS.js";const e="/assets/Snipaste_2024-06-29_13-03-23.CvnOHxC7.png",E="/assets/Snipaste_2024-06-29_13-09-13.BHkzPC00.png",r="/assets/Snipaste_2024-06-29_13-09-40.BaZqR3Ia.png",d="/assets/Snipaste_2024-06-29_13-10-10.Cr4aOhCT.png",g="/assets/Snipaste_2024-06-29_13-10-36.BsA-8dXY.png",y="/assets/Snipaste_2024-06-29_13-11-02.Bpsg8uUR.png",c="/assets/Snipaste_2024-06-29_13-11-30.BknFTjPX.png",u="/assets/Snipaste_2024-06-29_13-13-13.DbVxBTqz.png",_=JSON.parse('{"title":"数据库锁","description":"","frontmatter":{"title":"数据库锁"},"headers":[],"relativePath":"分布式锁/基于数据库的乐观锁和悲观锁.md","filePath":"分布式锁/基于数据库的乐观锁和悲观锁.md"}'),b={name:"分布式锁/基于数据库的乐观锁和悲观锁.md"},o=i("h2",{id:"乐观锁简介",tabindex:"-1"},[s("乐观锁简介 "),i("a",{class:"header-anchor",href:"#乐观锁简介","aria-label":'Permalink to "乐观锁简介"'},"​")],-1),F=k("",61);function m(A,D,C,B,v,q){const a=p("Badge");return t(),h("div",null,[o,i("p",null,[s("乐观锁是一种很 “佛系”的实现方式，总是认为不会产生并发的问题，故而每次从数据库获取数据时总认为不会有其他线程对该数据进行修改，因此不会上锁，但是在更新时会判断其他线程在只之前有没有对该数据进行修改，通常是采用版本号："),n(a,{type:"tip",text:"version"}),s(" 机制。")]),F,i("ul",null,[i("li",null,[i("p",null,[s("乐观锁，"),n(a,{type:"tip",text:"(版本号的相互排斥)主要采用的是版本号Version的机制实现"}),s("，故而在高并发产生多线程时，同一时刻只有一个线程能获取到”锁“并成功操作共享资源，而其他的线程将获取失败，而且是永久性地失败，从这个角度来看，这种方式虽然可以控制并发线程共享资源访问，但是却牺牲了系统的吞吐性能。 另外，乐观锁，主要是通过version字段对共享数据进行跟踪和控制，其最终一个实现步骤带上version进行匹配，同时执行version+1的更新操作，故而在并发多线程需要频繁”写“数据库时，是会严重影响数据库的性能的，从这个角度上看，乐观锁比较适合 ”写少读多“的业务场景。")])]),i("li",null,[i("p",null,[s("悲观锁，"),n(a,{type:"tip",text:"由于是建立在数据库底层搜索引擎的基础上"}),s("，并使用 "),n(a,{type:"tip",text:"select  * from where id =1 table for update "}),s(" 的查询语句对共享资源加锁，故而在高并发多线程请求，特别是 读 的请求时，将对数据的性能带来严重的影响，因为在同一时刻产生的多线程中将只有一个线程获取到锁，而其他的线程将处于堵塞状态，直到该线程释放了锁， 使用悲观锁要注意的是，如果使用不恰当很可能产生死锁的现象，即两个或者多个线程同时处于等待获取对方的资源的锁的状态，故而”悲观锁“更适用于读少写多的业务场景。")])])])])}const f=l(b,[["render",m]]);export{_ as __pageData,f as default};
