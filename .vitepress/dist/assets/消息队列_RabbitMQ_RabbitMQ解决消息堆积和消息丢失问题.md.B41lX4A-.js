import{_ as t,c as a,o as i,a1 as l}from"./chunks/framework.DFHaK-wS.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"消息队列/RabbitMQ/RabbitMQ解决消息堆积和消息丢失问题.md","filePath":"消息队列/RabbitMQ/RabbitMQ解决消息堆积和消息丢失问题.md"}'),e={name:"消息队列/RabbitMQ/RabbitMQ解决消息堆积和消息丢失问题.md"},o=l('<h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><ul><li><p>增加消费者或后台相关组件的吞吐能力</p></li><li><p>增加消费的多线程处理</p></li><li><p>根据不同的业务实现不同的丢弃任务，选择不同的策略淘汰任务</p></li><li><p>默认情况下，RabbitMQ消费者为单线程串行消费，设置并行消费两个关键属性，他们设置的是对每个消费者在初始化的时候设置的并发消费者个数，prefetchCount 是每次一次性从broker中获取的待消费的消息个数。</p></li><li><p>concurrentConsumer</p></li><li><p>prefetchConcurrentConsumer</p></li></ul><h2 id="消息丢失" tabindex="-1">消息丢失 <a class="header-anchor" href="#消息丢失" aria-label="Permalink to &quot;消息丢失&quot;">​</a></h2><p>解决方案</p><ul><li>持久化</li><li>消息确认机制</li></ul><p>​ 消息在生产者，消息队列，消费者中都有可能丢失。</p><h3 id="_1-在生产者中丢失" tabindex="-1">1. 在生产者中丢失 <a class="header-anchor" href="#_1-在生产者中丢失" aria-label="Permalink to &quot;1. 在生产者中丢失&quot;">​</a></h3><div class="info custom-block github-alert"><p class="custom-block-title">原因</p><p>生产者发送消息成功后，消息队列没有收到消息，消息在从生产者传输到队列的过程中丢失，一般可能是网络不稳定。</p></div><div class="tip custom-block github-alert"><p class="custom-block-title">​解决方案</p><p>发送方采用消息确认机制，当消息成功被MQ接收到后， 会给生产者发一个确认消息，表示成功接收。如果没有接受成功，重新用定时器去投递</p></div><h3 id="_2-在消息队列中丢失" tabindex="-1">2. 在消息队列中丢失 <a class="header-anchor" href="#_2-在消息队列中丢失" aria-label="Permalink to &quot;2. 在消息队列中丢失&quot;">​</a></h3><div class="info custom-block github-alert"><p class="custom-block-title">原因</p><p>消息到MQ后， 还没有被消费就被MQ给丢失了。比如MQ服务器宕机或者未进行持久化重启。</p></div><div class="tip custom-block github-alert"><p class="custom-block-title">解决方案</p><p>持久化交换机，队列和消息。确保MQ服务器重启时仍然能从磁盘恢复对应的队列，交换机和消息，然后我 们把MQ 做多台分布式集群，防止出现所有的MQ服务器挂掉。</p></div><div class="danger custom-block github-alert"><p class="custom-block-title">注意</p><p>交换机，队列和消息都要持久化。</p></div><h3 id="_3-在消费者中丢失" tabindex="-1">3. 在消费者中丢失 <a class="header-anchor" href="#_3-在消费者中丢失" aria-label="Permalink to &quot;3. 在消费者中丢失&quot;">​</a></h3><div class="info custom-block github-alert"><p class="custom-block-title">原因</p><p>默认消费者消费的时，设置的是自动回复MQ, 收到了消息，MQ会立刻删除自身保存的这条消息，如果消&gt; 息已经在MQ中被删除，但消费者的业务处理出现异常或者宕机，那么就导致改消息没有被成功处理从而导&gt; 致消息丢失。</p></div><div class="tip custom-block github-alert"><p class="custom-block-title">解决方案:设置手动ACK</p><p></p></div>',16),c=[o];function s(r,p,b,_,u,n){return i(),a("div",null,c)}const m=t(e,[["render",s]]);export{h as __pageData,m as default};
